{"version":3,"sources":["..\\..\\lib\\layout\\src\\Arranger\\Arranger.js","..\\..\\lib\\layout\\src\\CardArranger.js","..\\..\\lib\\layout\\src\\Panels\\Panels.js","..\\..\\lib\\layout\\src\\FittableLayout\\FittableLayout.js","..\\..\\lib\\layout\\src\\FlyweightRepeater.js","..\\..\\lib\\layout\\src\\FittableRows.js","..\\..\\lib\\layout\\src\\FittableColumns.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACv6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/**\r\n* Contains the declaration for the {@link module:layout/Arranger~Arranger} kind.\r\n* @module layout/Arranger\r\n*/\r\n\r\nvar\r\n\tkind = require('enyo/kind'),\r\n\tutils = require('enyo/utils'),\r\n\tplatform = require('enyo/platform');\r\n\r\nvar\r\n\tLayout = require('enyo/Layout'),\r\n\tDom = require('enyo/dom');\r\n\r\n/**\r\n* {@link module:layout/Arranger~Arranger} is an {@link module:enyo/Layout~Layout} that considers one of the\r\n* controls it lays out as active. The other controls are placed relative to\r\n* the active control as makes sense for the layout.\r\n*\r\n* `layout/Arranger` supports dynamic layouts, meaning it's possible to transition\r\n* between an arranger's layouts\tvia animation. Typically, arrangers should lay out\r\n* controls using CSS transforms, since these are optimized for animation. To\r\n* support this, the controls in an arranger are absolutely positioned, and\r\n* the Arranger kind has an [accelerated]{@link module:layout/Arranger~Arranger#accelerated} property,\r\n* which marks controls for CSS compositing. The default setting of `'auto'` ensures\r\n* that this will occur if enabled by the platform.\r\n*\r\n* For more information, see the documentation on\r\n* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the\r\n* Enyo Developer Guide.\r\n*\r\n* @class Arranger\r\n* @extends module:enyo/Layout~Layout\r\n* @public\r\n*/\r\nvar Arranger = module.exports = kind(\r\n\t/** @lends module:layout/Arranger~Arranger.prototype */ {\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tname: 'enyo.Arranger',\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tkind: Layout,\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tlayoutClass: 'enyo-arranger',\r\n\r\n\t/**\r\n\t* Flag indicating whether the Arranger should lay out controls using CSS\r\n\t* compositing. The default setting `('auto')` will mark controls for compositing\r\n\t* if the platform supports it.\r\n\t*\r\n\t* @type {String|Boolean}\r\n\t* @default 'auto'\r\n\t* @protected\r\n\t*/\r\n\taccelerated: 'auto',\r\n\r\n\t/**\r\n\t* A property of the drag event, used to calculate the amount that a drag will\r\n\t* move the layout.\r\n\t*\r\n\t* @type {String}\r\n\t* @default 'ddx'\r\n\t* @private\r\n\t*/\r\n\tdragProp: 'ddx',\r\n\r\n\t/**\r\n\t* A property of the drag event, used to calculate the direction of the drag.\r\n\t*\r\n\t* @type {String}\r\n\t* @default 'xDirection'\r\n\t* @private\r\n\t*/\r\n\tdragDirectionProp: 'xDirection',\r\n\r\n\t/**\r\n\t* A property of the drag event, used to calculate whether a drag should occur.\r\n\t*\r\n\t* @type {String}\r\n\t* @default 'horizontal'\r\n\t* @private\r\n\t*/\r\n\tcanDragProp: 'horizontal',\r\n\r\n\t/**\r\n\t* If set to `true`, transitions between non-adjacent arrangements will go\r\n\t* through the intermediate arrangements. This is useful when direct\r\n\t* transitions between arrangements would be visually jarring.\r\n\t*\r\n\t* @type {Boolean}\r\n\t* @default false\r\n\t* @protected\r\n\t*/\r\n\tincrementalPoints: false,\r\n\r\n\t/**\r\n\t* Called when removing an arranger (e.g., when switching a Panels control to a\r\n\t* different `arrangerKind`). Subkinds should implement this function to reset\r\n\t* whatever properties they've changed on child controls. Note that you **must**\r\n\t* call the superkind implementation in your subkind's `destroy()` function.\r\n\t*\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tdestroy: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tvar c$ = this.container.getPanels();\r\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\r\n\t\t\t\tc._arranger = null;\r\n\t\t\t}\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* Arranges the given array of `controls` in the layout specified by `index`. When\r\n\t* implementing this method, rather than applying styling directly to controls, call\r\n\t* [arrangeControl()]{@link module:layout/Arranger~Arranger#arrangeControl} and pass in an arrangement\r\n\t* object with styling settings. The styles will then be applied via\r\n\t* [flowControl()]{@link module:layout/Arranger~Arranger#flowControl}.\r\n\t*\r\n\t* @param {module:enyo/Control~Control[]} controls\r\n\t* @param {Number} index\r\n\t* @virtual\r\n\t* @protected\r\n\t*/\r\n\tarrange: function (controls, index) {\r\n\t},\r\n\r\n\t/**\r\n\t* Sizes the controls in the layout. This method is called only at reflow time.\r\n\t* Note that the sizing operation has been separated from the layout done in\r\n\t* [arrange()]{@link module:layout/Arranger~Arranger#arrange} because it is expensive and not suitable\r\n\t* for dynamic layout.\r\n\t*\r\n\t* @virtual\r\n\t* @protected\r\n\t*/\r\n\tsize: function () {\r\n\t},\r\n\r\n\t/**\r\n\t* Called when a layout transition begins. Implement this method to perform\r\n\t* tasks that should only occur when a transition starts; for example, some\r\n\t* controls might be shown or hidden. In addition, the `transitionPoints`\r\n\t* array may be set on the container to dictate the named arrangements\r\n\t* between which the transition occurs.\r\n\t*\r\n\t* @protected\r\n\t*/\r\n\tstart: function () {\r\n\t\tvar f = this.container.fromIndex, t = this.container.toIndex;\r\n\t\tvar p$ = this.container.transitionPoints = [f];\r\n\t\t// optionally add a transition point for each index between from and to.\r\n\t\tif (this.incrementalPoints) {\r\n\t\t\tvar d = Math.abs(t - f) - 2;\r\n\t\t\tvar i = f;\r\n\t\t\twhile (d >= 0) {\r\n\t\t\t\ti = i + (t < f ? -1 : 1);\r\n\t\t\t\tp$.push(i);\r\n\t\t\t\td--;\r\n\t\t\t}\r\n\t\t}\r\n\t\tp$.push(this.container.toIndex);\r\n\t},\r\n\r\n\t/**\r\n\t* Called when a layout transition completes. Implement this method to\r\n\t* perform tasks that should only occur when a transition ends; for\r\n\t* example, some controls might be shown or hidden.\r\n\t*\r\n\t* @virtual\r\n\t* @protected\r\n\t*/\r\n\tfinish: function () {\r\n\t},\r\n\r\n\t/**\r\n\t* Called when dragging the layout, this method returns the difference in\r\n\t* pixels between the arrangement `a0` for layout setting `i0`\tand\r\n\t* arrangement `a1` for layout setting `i1`. This data is used to calculate\r\n\t* the percentage that a drag should move the layout between two active states.\r\n\t*\r\n\t* @param {Number} i0 - The initial layout setting.\r\n\t* @param {Object} a0 - The initial arrangement.\r\n\t* @param {Number} i1 - The target layout setting.\r\n\t* @param {Object} a1 - The target arrangement.\r\n\t* @virtual\r\n\t* @protected\r\n\t*/\r\n\tcalcArrangementDifference: function (i0, a0, i1, a1) {\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tcanDragEvent: function (event) {\r\n\t\treturn event[this.canDragProp];\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tcalcDragDirection: function (event) {\r\n\t\treturn event[this.dragDirectionProp];\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tcalcDrag: function (event) {\r\n\t\treturn event[this.dragProp];\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdrag: function (dp, an, a, bn, b) {\r\n\t\tvar f = this.measureArrangementDelta(-dp, an, a, bn, b);\r\n\t\treturn f;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tmeasureArrangementDelta: function (x, i0, a0, i1, a1) {\r\n\t\tvar d = this.calcArrangementDifference(i0, a0, i1, a1);\r\n\t\tvar s = d ? x / Math.abs(d) : 0;\r\n\t\ts = s * (this.container.fromIndex > this.container.toIndex ? -1 : 1);\r\n\t\treturn s;\r\n\t},\r\n\r\n\t/**\r\n\t* Arranges the panels, with the panel at `index` being designated as active.\r\n\t*\r\n\t* @param  {Number} index - The index of the active panel.\r\n\t* @private\r\n\t*/\r\n\t_arrange: function (index) {\r\n\t\t// guard against being called before we've been rendered\r\n\t\tif (!this.containerBounds) {\r\n\t\t\tthis.reflow();\r\n\t\t}\r\n\t\tvar c$ = this.getOrderedControls(index);\r\n\t\tthis.arrange(c$, index);\r\n\t},\r\n\r\n\t/**\r\n\t* Arranges `control` according to the specified `arrangement`.\r\n\t*\r\n\t* Note that this method doesn't actually modify `control` but rather sets the\r\n\t* arrangement on a private member of the control to be retrieved by\r\n\t* {@link module:layout/Panels~Panels}.\r\n\t*\r\n\t* @param  {module:enyo/Control~Control} control\r\n\t* @param  {Object} arrangement\r\n\t* @private\r\n\t*/\r\n\tarrangeControl: function (control, arrangement) {\r\n\t\tcontrol._arranger = utils.mixin(control._arranger || {}, arrangement);\r\n\t},\r\n\r\n\t/**\r\n\t* Called before HTML is rendered. Applies CSS to panels to ensure GPU acceleration if\r\n\t* [accelerated]{@link module:layout/Arranger~Arranger#accelerated} is `true`.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tflow: function () {\r\n\t\tthis.c$ = [].concat(this.container.getPanels());\r\n\t\tthis.controlsIndex = 0;\r\n\t\tfor (var i=0, c$=this.container.getPanels(), c; (c=c$[i]); i++) {\r\n\t\t\tDom.accelerate(c, !c.preventAccelerate && this.accelerated);\r\n\t\t\tif (platform.safari) {\r\n\t\t\t\t// On Safari-desktop, sometimes having the panel's direct child set to accelerate isn't sufficient\r\n\t\t\t\t// this is most often the case with Lists contained inside another control, inside a Panels\r\n\t\t\t\tvar grands=c.children;\r\n\t\t\t\tfor (var j=0, kid; (kid=grands[j]); j++) {\r\n\t\t\t\t\tDom.accelerate(kid, this.accelerated);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Called during \"rendered\" phase to [size]{@link module:layout/Arranger~Arranger#size} the controls.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\treflow: function () {\r\n\t\tvar cn = this.container.hasNode();\r\n\t\tthis.containerBounds = cn ? {width: cn.clientWidth, height: cn.clientHeight} : {};\r\n\t\tthis.size();\r\n\t},\r\n\r\n\t/**\r\n\t* If the {@link module:layout/Panels~Panels} has an arrangement, flows each control according to that\r\n\t* arrangement.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tflowArrangement: function () {\r\n\t\tvar a = this.container.arrangement;\r\n\t\tif (a) {\r\n\t\t\tfor (var i=0, c$=this.container.getPanels(), c; (c=c$[i]) && (a[i]); i++) {\r\n\t\t\t\tthis.flowControl(c, a[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t/**\r\n\t* Lays out the given `control` according to the settings stored in the\r\n\t* `arrangement` object. By default, `flowControl()` will apply settings for\r\n\t* `left`, `top`, and `opacity`. This method should only be implemented to apply\r\n\t* other settings made via [arrangeControl()]{@link module:layout/Arranger~Arranger#arrangeControl}.\r\n\t*\r\n\t* @param {module:enyo/Control~Control} control - The control to be laid out.\r\n\t* @param {Object} arrangement - An object whose members specify the layout settings.\r\n\t* @protected\r\n\t*/\r\n\tflowControl: function (control, arrangement) {\r\n\t\tArranger.positionControl(control, arrangement);\r\n\t\tvar o = arrangement.opacity;\r\n\t\tif (o != null) {\r\n\t\t\tArranger.opacifyControl(control, o);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Gets an array of controls arranged in state order.\r\n\t* note: optimization, dial around a single array.\r\n\t*\r\n\t* @param  {Number} index     - The index of the active panel.\r\n\t* @return {module:enyo/Control~Control[]}   - Ordered array of controls.\r\n\t* @private\r\n\t*/\r\n\tgetOrderedControls: function (index) {\r\n\t\tvar whole = Math.floor(index);\r\n\t\tvar a = whole - this.controlsIndex;\r\n\t\tvar sign = a > 0;\r\n\t\tvar c$ = this.c$ || [];\r\n\t\tfor (var i=0; i<Math.abs(a); i++) {\r\n\t\t\tif (sign) {\r\n\t\t\t\tc$.push(c$.shift());\r\n\t\t\t} else {\r\n\t\t\t\tc$.unshift(c$.pop());\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.controlsIndex = whole;\r\n\t\treturn c$;\r\n\t}\r\n});\r\n\r\n/**\r\n* Positions a control via transform--`translateX/translateY` if supported,\r\n* falling back to `left/top` if not.\r\n*\r\n* @lends module:layout/Arranger~Arranger\r\n* @param  {module:enyo/Control~Control} control - The control to position.\r\n* @param  {Object} bounds        - The new bounds for `control`.\r\n* @param  {String} unit          - The unit for `bounds` members.\r\n* @public\r\n*/\r\nArranger.positionControl = function (control, bounds, unit) {\r\n\tunit = unit || 'px';\r\n\tif (!this.updating) {\r\n\t\t// IE10 uses setBounds because of control hit caching problems seem in some apps\r\n\t\tif (Dom.canTransform() && !control.preventTransform && platform.ie !== 10) {\r\n\t\t\tvar l = bounds.left, t = bounds.top;\r\n\t\t\tl = utils.isString(l) ? l : l && (l + unit);\r\n\t\t\tt = utils.isString(t) ? t : t && (t + unit);\r\n\t\t\tDom.transform(control, {translateX: l || null, translateY: t || null});\r\n\t\t} else {\r\n\t\t\t// If a previously positioned control has subsequently been marked with\r\n\t\t\t// preventTransform, we need to clear out any old translation values.\r\n\t\t\tif (Dom.canTransform() && control.preventTransform) {\r\n\t\t\t\tDom.transform(control, {translateX: null, translateY: null});\r\n\t\t\t}\r\n\t\t\tcontrol.setBounds(bounds, unit);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n* Sets the opacity value for a given control.\r\n*\r\n* @lends module:layout/Arranger~Arranger\r\n* @param {module:enyo/Control~Control} inControl - The control whose opacity is to be set.\r\n* @param {Number} inOpacity - The new opacity value for the control.\r\n* @public\r\n*/\r\nArranger.opacifyControl = function (inControl, inOpacity) {\r\n\t// FIXME: very high/low settings of opacity can cause a control to\r\n\t// blink so cap this here.\r\n\tinControl.applyStyle('opacity', inOpacity > 0.99 ? 1 : (inOpacity < 0.01 ? 0 : inOpacity));\r\n};\r\n","/**\r\n* Contains the declaration for the {@link module:layout/CardArranger~CardArranger} kind.\r\n* @module layout/CardArranger\r\n*/\r\n\r\nvar\r\n\tkind = require('enyo/kind');\r\n\r\nvar\r\n\tArranger = require('./Arranger');\r\n\r\n\r\n/**\r\n* {@link module:layout/CardArranger~CardArranger} is a {@link module:layout/Arranger~Arranger}\r\n* that displays only one active control. The non-active controls are hidden with\r\n* `setShowing(false)`. Transitions between arrangements are handled by fading\r\n* from one control to the next.\r\n*\r\n* For more information, see the documentation on\r\n* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the\r\n* Enyo Developer Guide.\r\n*\r\n* @class CardArranger\r\n* @extends module:layout/Arranger~Arranger\r\n* @public\r\n*/\r\nmodule.exports = kind(\r\n\t/** @lends module:layout/CardArranger~CardArranger.prototype */ {\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tname: 'enyo.CardArranger',\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tkind: Arranger,\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tlayoutClass: 'enyo-arranger enyo-arranger-fit',\r\n\r\n\t/**\r\n\t* @see {@link module:layout/Arranger~Arranger#calcArrangementDifference}\r\n\t* @protected\r\n\t*/\r\n\tcalcArrangementDifference: function (i0, a0, i1, a1) {\r\n\t\treturn this.containerBounds.width;\r\n\t},\r\n\r\n\t/**\r\n\t* Applies opacity to the activation and deactivation of panels. Expects the passed-in\r\n\t* array of controls to be ordered such that the first control in the array is the active\r\n\t* panel.\r\n\t*\r\n\t* @see {@link module:layout/Arranger~Arranger#arrange}\r\n\t* @protected\r\n\t*/\r\n\tarrange: function (controls, arrangement) {\r\n\t\tfor (var i=0, c, v; (c=controls[i]); i++) {\r\n\t\t\tv = (i === 0) ? 1 : 0;\r\n\t\t\tthis.arrangeControl(c, {opacity: v});\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Shows the active panel at the start of transition. Also triggers a resize on\r\n\t* the active panel if it wasn't previously showing.\r\n\t*\r\n\t* @see {@link module:layout/Arranger~Arranger#start}\r\n\t* @method\r\n\t* @protected\r\n\t*/\r\n\tstart: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t\tvar c$ = this.container.getPanels();\r\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\r\n\t\t\t\tvar wasShowing=c.showing;\r\n\t\t\t\tc.setShowing(i == this.container.fromIndex || i == (this.container.toIndex));\r\n\t\t\t\tif (c.showing && !wasShowing) {\r\n\t\t\t\t\tc.resize();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* Hides all non-active panels when the transition completes.\r\n\t*\r\n\t* @see {@link module:layout/Arranger~Arranger#finish}\r\n\t* @method\r\n\t* @protected\r\n\t*/\r\n\tfinish: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t\tvar c$ = this.container.getPanels();\r\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\r\n\t\t\t\tc.setShowing(i == this.container.toIndex);\r\n\t\t\t}\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* Ensures all panels are showing and visible when the arranger is destroyed.\r\n\t*\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tdestroy: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tvar c$ = this.container.getPanels();\r\n\t\t\tfor (var i=0, c; (c=c$[i]); i++) {\r\n\t\t\t\tArranger.opacifyControl(c, 1);\r\n\t\t\t\tif (!c.showing) {\r\n\t\t\t\t\tc.setShowing(true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t};\r\n\t})\r\n});\r\n","/**\r\n* Contains the declaration for the {@link module:layout/Panels~Panels} kind.\r\n* @module layout/Panels\r\n*/\r\n\r\nvar\r\n\tkind = require('enyo/kind'),\r\n\tdispatcher = require('enyo/dispatcher'),\r\n\tdom = require('enyo/dom'),\r\n\tplatform = require('enyo/platform'),\r\n\tutils = require('enyo/utils'),\r\n\tAnimator = require('enyo/Animator');\r\n\r\nvar\r\n\tCardArranger = require('../CardArranger');\r\n\r\n/**\r\n* Fires at the start of a panel transition, when [setIndex()]{@link module:layout/Panels~Panels#setIndex}\r\n* is called, and also during dragging.\r\n*\r\n* @event module:layout/Panels~Panels#onTransitionStart\r\n* @type {Object}\r\n* @property {Number} fromIndex - The index of the old panel.\r\n* @property {Number} toIndex   - The index of the new panel.\r\n* @public\r\n*/\r\n\r\n/**\r\n* Fires at the end of a panel transition, when [setIndex()]{@link module:layout/Panels~Panels#setIndex}\r\n* is called, and also during dragging.\r\n*\r\n* @event module:layout/Panels~Panels#onTransitionFinish\r\n* @type {Object}\r\n* @property {Number} fromIndex - The index of the old panel.\r\n* @property {Number} toIndex   - The index of the new panel.\r\n* @public\r\n*/\r\n\r\n/**\r\n* The {@link module:layout/Panels~Panels} kind is designed to satisfy a variety of common use cases\r\n* for application layout. Using `Panels`, controls may be arranged as (among\r\n* other things) a carousel, a set of collapsing panels, a card stack that fades\r\n* between panels, or a grid.\r\n*\r\n* Any Enyo control may be placed inside a `Panels`, but by convention we\r\n* refer to each of these controls as a \"panel\". From the set of panels in a\r\n* `Panels`, one is considered to be active. The active panel is set by index\r\n* using the [setIndex()]{@link module:layout/Panels~Panels#setIndex} method. The actual layout of\r\n* the panels typically changes each time the active panel is set, such that the new\r\n* active panel has the most prominent position.\r\n*\r\n* For more information, see the documentation on\r\n* [Panels]{@linkplain $dev-guide/building-apps/layout/panels.html} in the\r\n* Enyo Developer Guide.\r\n*\r\n* @class Panels\r\n* @extends module:enyo/Control~Control\r\n* @ui\r\n* @public\r\n*/\r\nvar Panels = module.exports = kind(\r\n\t/** @lends module:layout/Panels~Panels.prototype */ {\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tname: 'enyo.Panels',\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tclasses: 'enyo-panels',\r\n\r\n\t/**\r\n\t* @lends module:layout/Panels~Panels.prototype\r\n\t* @private\r\n\t*/\r\n\tpublished: {\r\n\t\t/**\r\n\t\t* The index of the active panel. The layout of panels is controlled by the\r\n\t\t* [layoutKind]{@link module:layout/Panels~Panels#layoutKind}, but as a rule, the active panel\r\n\t\t* is displayed in the most prominent position. For example, in the (default)\r\n\t\t* {@link module:layout/CardArranger~CardArranger} layout, the active panel is shown and the other\r\n\t\t* panels are hidden.\r\n\t\t*\r\n\t\t* @type {Number}\r\n\t\t* @default  0\r\n\t\t* @public\r\n\t\t*/\r\n\t\tindex: 0,\r\n\r\n\t\t/**\r\n\t\t* Indicates whether the user may drag between panels.\r\n\t\t*\r\n\t\t* @type {Boolean}\r\n\t\t* @default  true\r\n\t\t* @public\r\n\t\t*/\r\n\t\tdraggable: true,\r\n\r\n\t\t/**\r\n\t\t* Indicates whether the panels animate when transitioning, e.g., when\r\n\t\t* [setIndex()]{@link module:layout/Panels~Panels#setIndex} is called.\r\n\t\t*\r\n\t\t* @type {Boolean}\r\n\t\t* @default  true\r\n\t\t* @public\r\n\t\t*/\r\n\t\tanimate: true,\r\n\r\n\t\t/**\r\n\t\t* Indicates whether panels \"wrap around\" when moving past the end.\r\n\t\t* The actual effect depends upon the arranger in use.\r\n\t\t*\r\n\t\t* @type {Boolean}\r\n\t\t* @default  false\r\n\t\t* @public\r\n\t\t*/\r\n\t\twrap: false,\r\n\r\n\t\t/**\r\n\t\t* The arranger kind to be used for dynamic layout.\r\n\t\t*\r\n\t\t* @type {String}\r\n\t\t* @default  'CardArranger'\r\n\t\t* @public\r\n\t\t*/\r\n\t\tarrangerKind: CardArranger,\r\n\r\n\t\t/**\r\n\t\t* By default, each panel will be sized to fit the Panels' width when the\r\n\t\t* screen size is sufficiently narrow (less than 800px). Set to `false` to\r\n\t\t* avoid this behavior.\r\n\t\t*\r\n\t\t* @type {Boolean}\r\n\t\t* @default  true\r\n\t\t* @public\r\n\t\t*/\r\n\t\tnarrowFit: true\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tevents: {\r\n\t\tonTransitionStart: '',\r\n\t\tonTransitionFinish: ''\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\thandlers: {\r\n\t\tondragstart: 'dragstart',\r\n\t\tondrag: 'drag',\r\n\t\tondragfinish: 'dragfinish',\r\n\t\tonscroll: 'domScroll'\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\ttools: [\r\n\t\t{kind: Animator, onStep: 'step', onEnd: 'animationEnded'}\r\n\t],\r\n\r\n\t/**\r\n\t* Tracks completion percentage for a transition between two panels.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tfraction: 0,\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tcreate: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tthis.transitionPoints = [];\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t\tthis.arrangerKindChanged();\r\n\t\t\tthis.narrowFitChanged();\r\n\t\t\tthis.indexChanged();\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\trendered: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t\tdispatcher.makeBubble(this, 'scroll');\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdomScroll: function (sender, event) {\r\n\t\tif (this.hasNode()) {\r\n\t\t\tif (this.node.scrollLeft > 0) {\r\n\t\t\t\t// Reset scrollLeft position\r\n\t\t\t\tthis.node.scrollLeft = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tinitComponents: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tthis.createChrome(this.tools);\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tarrangerKindChanged: function () {\r\n\t\tthis.setLayoutKind(this.arrangerKind);\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tnarrowFitChanged: function () {\r\n\t\tthis.addRemoveClass(Panels.getNarrowClass(), this.narrowFit);\r\n\t},\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tdestroy: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\t// When the entire panels is going away, take note so we don't try and do single-panel\r\n\t\t\t// remove logic such as changing the index and reflowing when each panel is destroyed\r\n\t\t\tthis.destroying = true;\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* Adjusts the index if the removed control is the active panel and reflows the layout.\r\n\t*\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tremoveControl: kind.inherit(function (sup) {\r\n\t\treturn function (control) {\r\n\t\t\t// Skip extra work during panel destruction.\r\n\t\t\tif (this.destroying) {\r\n\t\t\t\treturn sup.apply(this, arguments);\r\n\t\t\t}\r\n\t\t\t// adjust index if the current panel is being removed\r\n\t\t\t// so it's either the previous panel or the first one.\r\n\t\t\tvar newIndex = -1;\r\n\t\t\tvar controlIndex = utils.indexOf(control, this.controls);\r\n\t\t\tif (controlIndex === this.index) {\r\n\t\t\t\tnewIndex = Math.max(controlIndex - 1, 0);\r\n\t\t\t}\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t\tif (newIndex !== -1 && this.controls.length > 0) {\r\n\t\t\t\tthis.setIndex(newIndex);\r\n\t\t\t\tthis.flow();\r\n\t\t\t\tthis.reflow();\r\n\t\t\t}\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* Designed to be overridden in kinds derived from Panels that have\r\n\t* non-panel client controls.\r\n\t*\r\n\t* @return {Boolean} [description]\r\n\t* @protected\r\n\t* @todo  Assume that this should take a control as a parameter.\r\n\t*/\r\n\tisPanel: function () {\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tflow: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tthis.arrangements = [];\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\treflow: kind.inherit(function (sup) {\r\n\t\treturn function () {\r\n\t\t\tthis.arrangements = [];\r\n\t\t\tsup.apply(this, arguments);\r\n\t\t\tthis.refresh();\r\n\t\t};\r\n\t}),\r\n\r\n\t/**\r\n\t* Returns the array of contained panels. Subclasses may override this if they\r\n\t* don't want the arranger to lay out all of their children.\r\n\t*\r\n\t* @return {module:enyo/Control~Control[]} - The array of contained panels.\r\n\t*/\r\n\tgetPanels: function () {\r\n\t\tvar p = this.controlParent || this;\r\n\t\treturn p.children;\r\n\t},\r\n\r\n\t/**\r\n\t* Returns a reference to the active panel--i.e., the panel at the specified index.\r\n\t*\r\n\t* @return {module:enyo/Control~Control} - The active panel.\r\n\t*/\r\n\tgetActive: function () {\r\n\t\tvar p$ = this.getPanels();\r\n\t\t//Constrain the index within the array of panels, needed if wrapping is enabled\r\n\t\tvar index = this.index % p$.length;\r\n\t\tif (index < 0) {\r\n\t\t\tindex += p$.length;\r\n\t\t}\r\n\t\treturn p$[index];\r\n\t},\r\n\r\n\t/**\r\n\t* Returns a reference to the {@link module:enyo/Animator~Animator} instance used to\r\n\t* animate panel transitions. The Panels' animator may be used to set the\r\n\t* duration of panel transitions, e.g.:\r\n\t*\r\n\t* ```\r\n\t* this.getAnimator().setDuration(1000);\r\n\t* ```\r\n\t*\r\n\t* @return {module:enyo/Animator~Animator} - The {@link module:enyo/Animator~Animator} instance used to animate\r\n\t* panel transitions.\r\n\t* @public\r\n\t*/\r\n\tgetAnimator: function () {\r\n\t\treturn this.$.animator;\r\n\t},\r\n\r\n\t/**\r\n\t* Sets the active panel to the panel specified by the given index.\r\n\t* Note that if the [animate]{@link module:layout/Panels~Panels#animate} property is set to\r\n\t* `true`, the active panel will animate into view.\r\n\t*\r\n\t* @param {Number} index - The index of the panel to activate.\r\n\t* @public\r\n\t*/\r\n\tsetIndex: function (index) {\r\n\t\t// override setIndex so that indexChanged is called\r\n\t\t// whether this.index has actually changed or not. Also, do\r\n\t\t// index clamping here.\r\n\t\tvar prevIndex = this.get('index'),\r\n\t\t\tnewIndex = this.clamp(index);\r\n\t\tthis.index = newIndex;\r\n\t\tthis.notifyObservers('index', prevIndex, newIndex);\r\n\t},\r\n\r\n\t/**\r\n\t* Sets the active panel to the panel specified by the given index.\r\n\t* The transition to the next panel will be immediate and will not be animated,\r\n\t* regardless of the value of the [animate]{@link module:layout/Panels~Panels#animate} property.\r\n\t*\r\n\t* @param {Number} index - The index of the panel to activate.\r\n\t* @public\r\n\t*/\r\n\tsetIndexDirect: function (index) {\r\n\t\tif (this.animate) {\r\n\t\t\tthis.animate = false;\r\n\t\t\tthis.setIndex(index);\r\n\t\t\tthis.animate = true;\r\n\t\t} else {\r\n\t\t\tthis.setIndex(index);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Selects the named component owned by the Panels and returns its index.\r\n\t*\r\n\t* @param  {String} name - The name of the panel to activate.\r\n\t* @return {Number} The index of the newly activated panel.\r\n\t* @public\r\n\t*/\r\n\tselectPanelByName: function (name) {\r\n\t\tif (!name) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar idx = 0;\r\n\t\tvar panels = this.getPanels();\r\n\t\tvar len = panels.length;\r\n\t\tfor (; idx < len; ++idx) {\r\n\t\t\tif (name === panels[idx].name) {\r\n\t\t\t\tthis.setIndex(idx);\r\n\t\t\t\treturn idx;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Transitions to the previous panel--i.e., the panel whose index value is one\r\n\t* less than that of the current active panel.\r\n\t*\r\n\t* @public\r\n\t*/\r\n\tprevious: function () {\r\n\t\tvar prevIndex = this.index - 1;\r\n\t\tif (this.wrap && prevIndex < 0) {\r\n\t\t\tprevIndex = this.getPanels().length - 1;\r\n\t\t}\r\n\t\tthis.setIndex(prevIndex);\r\n\t},\r\n\r\n\t/**\r\n\t* Transitions to the next panel--i.e., the panel whose index value is one\r\n\t* greater than that of the current active panel.\r\n\t*\r\n\t* @public\r\n\t*/\r\n\tnext: function () {\r\n\t\tvar nextIndex = this.index+1;\r\n\t\tif (this.wrap && nextIndex >= this.getPanels().length) {\r\n\t\t\tnextIndex = 0;\r\n\t\t}\r\n\t\tthis.setIndex(nextIndex);\r\n\t},\r\n\r\n\t/**\r\n\t* Ensures that `value` references a valid panel, accounting for\r\n\t* [wrapping]{@link module:layout/Panels~Panels#wrap}.\r\n\t*\r\n\t* @param  {Number} value - The index of a panel.\r\n\t* @return {Number}       - The valid index of a panel.\r\n\t* @private\r\n\t*/\r\n\tclamp: function (value) {\r\n\t\tvar l = this.getPanels().length;\r\n\t\tif (this.wrap) {\r\n\t\t\t// FIXME: dragging makes assumptions about direction and from->start indexes.\r\n\t\t\t//return value < 0 ? l : (value > l ? 0 : value);\r\n\t\t\tvalue %= l;\r\n\t\t\treturn (value < 0) ? value + l : value;\r\n\t\t} else {\r\n\t\t\treturn Math.max(0, Math.min(value, l - 1));\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tindexChanged: function (old) {\r\n\t\tthis.lastIndex = old;\r\n\t\tif (!this.dragging && this.$.animator && this.hasNode()) {\r\n\t\t\tif (this.shouldAnimate()) {\r\n\t\t\t\t// If we're mid-transition, complete it and indicate we need to transition\r\n\t\t\t\tif (this.$.animator.isAnimating()) {\r\n\t\t\t\t\tthis.transitionOnComplete = true;\r\n\t\t\t\t\tthis.$.animator.complete();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.animateTransition();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.directTransition();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Returns `true` if the panels should animate in the transition from `fromIndex` to\r\n\t* `toIndex`. This can be overridden in a {@glossary subkind} for greater customization.\r\n\t*\r\n\t* @protected\r\n\t*/\r\n\tshouldAnimate: function () {\r\n\t\treturn this.animate;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tstep: function (sender) {\r\n\t\tthis.fraction = sender.value;\r\n\t\tthis.stepTransition();\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tanimationEnded: function (sender, event) {\r\n\t\tthis.completed();\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tcompleted: function () {\r\n\t\tthis.finishTransition();\r\n\r\n\t\t// Animator.onEnd fires asynchronously so we need an internal flag to indicate we need\r\n\t\t// to start the next transition when the previous completes\r\n\t\tif (this.transitionOnComplete) {\r\n\t\t\tthis.transitionOnComplete = false;\r\n\t\t\tthis.animateTransition();\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdragstart: function (sender, event) {\r\n\t\tif (this.draggable && this.layout && this.layout.canDragEvent(event)) {\r\n\t\t\tevent.preventDefault();\r\n\t\t\tthis.dragstartTransition(event);\r\n\t\t\tthis.dragging = true;\r\n\t\t\tthis.$.animator.stop();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdrag: function (sender, event) {\r\n\t\tif (this.dragging) {\r\n\t\t\tevent.preventDefault();\r\n\t\t\tthis.dragTransition(event);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdragfinish: function (sender, event) {\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.dragging = false;\r\n\t\t\tevent.preventTap();\r\n\t\t\tthis.dragfinishTransition(event);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdragstartTransition: function (event) {\r\n\t\tif (!this.$.animator.isAnimating()) {\r\n\t\t\tvar f = this.fromIndex = this.index;\r\n\t\t\tthis.toIndex = f - (this.layout ? this.layout.calcDragDirection(event) : 0);\r\n\t\t} else {\r\n\t\t\tthis.verifyDragTransition(event);\r\n\t\t}\r\n\t\tthis.fromIndex = this.clamp(this.fromIndex);\r\n\t\tthis.toIndex = this.clamp(this.toIndex);\r\n\t\t//this.log(this.fromIndex, this.toIndex);\r\n\t\tthis.fireTransitionStart();\r\n\t\tif (this.layout) {\r\n\t\t\tthis.layout.start();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdragTransition: function (event) {\r\n\t\t// note: for simplicity we choose to calculate the distance directly between\r\n\t\t// the first and last transition point.\r\n\t\tvar d = this.layout ? this.layout.calcDrag(event) : 0;\r\n\t\tvar t$ = this.transitionPoints, s = t$[0], f = t$[t$.length-1];\r\n\t\tvar as = this.fetchArrangement(s);\r\n\t\tvar af = this.fetchArrangement(f);\r\n\t\tvar dx = this.layout ? this.layout.drag(d, s, as, f, af) : 0;\r\n\t\tvar dragFail = d && !dx;\r\n\t\tif (dragFail) {\r\n\t\t\t//this.log(dx, s, as, f, af);\r\n\t\t}\r\n\t\tthis.fraction += dx;\r\n\t\tvar fr = this.fraction;\r\n\t\tif (fr > 1 || fr < 0 || dragFail) {\r\n\t\t\tif (fr > 0 || dragFail) {\r\n\t\t\t\tthis.dragfinishTransition(event);\r\n\t\t\t}\r\n\t\t\tthis.dragstartTransition(event);\r\n\t\t\tthis.fraction = 0;\r\n\t\t\t// FIXME: account for lost fraction\r\n\t\t\t//this.dragTransition(event);\r\n\t\t}\r\n\t\tthis.stepTransition();\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdragfinishTransition: function (event) {\r\n\t\tthis.verifyDragTransition(event);\r\n\t\tthis.setIndex(this.toIndex);\r\n\t\t// note: if we're still dragging, then we're at a transition boundary\r\n\t\t// and should fire the finish event\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.fireTransitionFinish();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tverifyDragTransition: function (event) {\r\n\t\tvar d = this.layout ? this.layout.calcDragDirection(event) : 0;\r\n\t\tvar f = Math.min(this.fromIndex, this.toIndex);\r\n\t\tvar t = Math.max(this.fromIndex, this.toIndex);\r\n\t\tif (d > 0) {\r\n\t\t\tvar s = f;\r\n\t\t\tf = t;\r\n\t\t\tt = s;\r\n\t\t}\r\n\t\tif (f != this.fromIndex) {\r\n\t\t\tthis.fraction = 1 - this.fraction;\r\n\t\t}\r\n\t\t//this.log('old', this.fromIndex, this.toIndex, 'new', f, t);\r\n\t\tthis.fromIndex = f;\r\n\t\tthis.toIndex = t;\r\n\t},\r\n\r\n\t/**\r\n\t* Resets the panels without sending any events.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\trefresh: function () {\r\n\t\tif (this.$.animator && this.$.animator.isAnimating()) {\r\n\t\t\tthis.$.animator.stop();\r\n\t\t}\r\n\t\tthis.setupTransition();\r\n\t\tthis.fraction = 1;\r\n\t\tthis.stepTransition();\r\n\t\tthis.transitioning = false;\r\n\t\tthis.completeTransition();\r\n\t\tthis.dragging = false;\r\n\t},\r\n\r\n\t/**\r\n\t* Transitions to the new index without animation\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tdirectTransition: function () {\r\n\t\tthis.startTransition();\r\n\t\tthis.fraction = 1;\r\n\t\tthis.stepTransition();\r\n\t\tthis.finishTransition();\r\n\t},\r\n\r\n\t/**\r\n\t* Animates the transition to the new index\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tanimateTransition: function () {\r\n\t\tthis.startTransition();\r\n\t\tthis.$.animator.play({\r\n\t\t\tstartValue: this.fraction\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t* Starts the transition between two panels. if a transition is already in progress, this is\r\n\t* a no-op.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tstartTransition: function () {\r\n\t\tif (!this.transitioning) {\r\n\t\t\tthis.transitioning = true;\r\n\t\t\tthis.setupTransition();\r\n\t\t\tthis.fireTransitionStart();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Sets up transition state\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tsetupTransition: function () {\r\n\t\tthis.fromIndex = this.fromIndex != null ? this.fromIndex : this.lastIndex || 0;\r\n\t\tthis.toIndex = this.toIndex != null ? this.toIndex : this.index;\r\n\t\tif (this.layout) {\r\n\t\t\tthis.layout.start();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Completes the transition between two panels.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tfinishTransition: function () {\r\n\t\tthis.transitioning = false;\r\n\t\tthis.completeTransition(true);\r\n\t},\r\n\r\n\t/**\r\n\t* Completes the transition by performing any tasks to be run when the transition ends,\r\n\t* including firing events and clean-up.\r\n\t*\r\n\t* @param {Boolean} [fire] - If `true`, will fire the {@link module:layout/Panels~Panels#onTransitionFinish}\r\n\t*\tevent if deemed necessary.\r\n\t* @private\r\n\t*/\r\n\tcompleteTransition: function (fire) {\r\n\t\tif (this.layout) {\r\n\t\t\tthis.layout.finish();\r\n\t\t}\r\n\r\n\t\tif (fire) {\r\n\t\t\tthis.fireTransitionFinish(true);\r\n\t\t} else {\r\n\t\t\tthis.clearTransitionData();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Clears transition-related data.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tclearTransitionData: function() {\r\n\t\tthis.transitionPoints = [];\r\n\t\tthis.fraction = 0;\r\n\t\tthis.fromIndex = this.toIndex = null;\r\n\t},\r\n\r\n\t/**\r\n\t* @fires module:layout/Panels~Panels#onTransitionStart\r\n\t* @private\r\n\t*/\r\n\tfireTransitionStart: function () {\r\n\t\tvar t = this.startTransitionInfo;\r\n\t\tif (this.hasNode() && (!t || (t.fromIndex != this.fromIndex || t.toIndex != this.toIndex))) {\r\n\t\t\tthis.startTransitionInfo = {fromIndex: this.fromIndex, toIndex: this.toIndex};\r\n\t\t\tthis.doTransitionStart(utils.clone(this.startTransitionInfo));\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @fires module:layout/Panels~Panels#onTransitionFinish\r\n\t* @param {Boolean} [clearData] - If `true`, {@link module:layout/Panels~Panels#clearTransitionData} will be\r\n\t*\tcalled after recording the values needed for the callback.\r\n\t* @private\r\n\t*/\r\n\tfireTransitionFinish: function (clearData) {\r\n\t\tvar t = this.finishTransitionInfo,\r\n\t\t\tfromIndex = t ? t.fromIndex : null,\r\n\t\t\ttoIndex = t ? t.toIndex : null;\r\n\t\tif (this.hasNode() && (!t || (fromIndex != this.fromIndex || toIndex != this.toIndex))) {\r\n\t\t\t\tif (this.transitionOnComplete) {\r\n\t\t\t\tthis.finishTransitionInfo = {fromIndex: toIndex, toIndex: this.lastIndex};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.finishTransitionInfo = {fromIndex: this.lastIndex, toIndex: this.index};\r\n\t\t\t\t}\r\n\t\t\tif (clearData) {\r\n\t\t\t\tthis.clearTransitionData();\r\n\t\t\t}\r\n\t\t\t\tthis.doTransitionFinish(utils.clone(this.finishTransitionInfo));\r\n\t\t} else if (clearData) {\r\n\t\t\tthis.clearTransitionData();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Interpolates between arrangements as needed.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tstepTransition: function () {\r\n\t\tif (this.hasNode()) {\r\n\t\t\t// select correct transition points and normalize fraction.\r\n\t\t\tvar t$ = this.transitionPoints;\r\n\t\t\tvar r = (this.fraction || 0) * (t$.length-1);\r\n\t\t\tvar i = Math.floor(r);\r\n\t\t\tr = r - i;\r\n\t\t\tvar s = t$[i], f = t$[i+1];\r\n\t\t\t// get arrangements and lerp between them\r\n\t\t\tvar s0 = this.fetchArrangement(s);\r\n\t\t\tvar s1 = this.fetchArrangement(f);\r\n\t\t\tthis.arrangement = s0 && s1 ? Panels.lerp(s0, s1, r) : (s0 || s1);\r\n\t\t\tif (this.arrangement && this.layout) {\r\n\t\t\t\tthis.layout.flowArrangement();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Fetches the arrangement at a specified index, initializing it if necessary.\r\n\t*\r\n\t* @param  {Number} index - The index of the desired arrangement from `transitionPoints`.\r\n\t* @return {Object} The desired arrangement object.\r\n\t* @private\r\n\t*/\r\n\tfetchArrangement: function (index) {\r\n\t\tif ((index != null) && !this.arrangements[index] && this.layout) {\r\n\t\t\tthis.layout._arrange(index);\r\n\t\t\tthis.arrangements[index] = this.readArrangement(this.getPanels());\r\n\t\t}\r\n\t\treturn this.arrangements[index];\r\n\t},\r\n\r\n\t/**\r\n\t* Iterates over `panels` and retrieves a copy of each panel's `_arranger`.\r\n\t*\r\n\t* @param  {module:enyo/Control~Control[]} panels - The array of panels.\r\n\t* @return {Object[]}              - The array of arrangement objects.\r\n\t*/\r\n\treadArrangement: function (panels) {\r\n\t\tvar r = [];\r\n\t\tfor (var i=0, c$=panels, c; (c=c$[i]); i++) {\r\n\t\t\tr.push(utils.clone(c._arranger));\r\n\t\t}\r\n\t\treturn r;\r\n\t},\r\n\r\n\t/**\r\n\t* @lends module:layout/Panels~Panels\r\n\t* @private\r\n\t*/\r\n\tstatics: {\r\n\t\t/**\r\n\t\t* Returns `true` for iOS and Android phone form factors, or when window width\r\n\t\t* is 800px or less. Approximates work done using media queries in `Panels.css`.\r\n\t\t*\r\n\t\t* @return {Boolean} `true` for narrow devices or viewports; otherwise, `false`.\r\n\t\t* @public\r\n\t\t*/\r\n\t\tisScreenNarrow: function () {\r\n\t\t\tif(Panels.isNarrowDevice()) {\r\n\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\treturn dom.getWindowWidth() <= 800;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t* Returns the class name to apply for narrow fitting. See media queries\r\n\t\t* in `Panels.css`.\r\n\t\t*\r\n\t\t* @return {String} The CSS class name to apply.\r\n\t\t*/\r\n\t\tgetNarrowClass: function () {\r\n\t\t\tif(Panels.isNarrowDevice()) {\r\n\t\t\t\treturn 'enyo-panels-force-narrow';\r\n\t\t\t} else {\r\n\t\t\t\treturn 'enyo-panels-fit-narrow';\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t* Lerps between arrangements.\r\n\t\t*\r\n\t\t* @param  {Object[]} a0     - Array of current arrangement objects.\r\n\t\t* @param  {Object[]} a1     - Array of target arrangement object.\r\n\t\t* @param  {Number} fraction - The fraction (between 0 and 1) with which to lerp.\r\n\t\t* @return {Object[]}        - Array of arrangements that is `fraction` between\r\n\t\t* \t`a0` and `a1`.\r\n\t\t* @private\r\n\t\t*/\r\n\t\tlerp: function (a0, a1, fraction) {\r\n\t\t\tvar r = [];\r\n\t\t\tfor (var i=0, k$=utils.keys(a0), k; (k=k$[i]); i++) {\r\n\t\t\t\tr.push(this.lerpObject(a0[k], a1[k], fraction));\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t* Lerps between the values of arrangement objects.\r\n\t\t*\r\n\t\t* @param  {Object} a0       - The source arragement.\r\n\t\t* @param  {Object} a1       - The destination arragement.\r\n\t\t* @param  {Number} fraction - The fraction (between 0 and 1) with which to lerp.\r\n\t\t*\r\n\t\t* @return {Object}          - The lerped arrangement.\r\n\t\t* @private\r\n\t\t*/\r\n\t\tlerpObject: function (a0, a1, fraction) {\r\n\t\t\tvar b = utils.clone(a0), n, o;\r\n\t\t\t// a1 might be undefined when deleting panels\r\n\t\t\tif (a1) {\r\n\t\t\t\tfor (var i in a0) {\r\n\t\t\t\t\tn = a0[i];\r\n\t\t\t\t\to = a1[i];\r\n\t\t\t\t\tif (n != o) {\r\n\t\t\t\t\t\tb[i] = n - (n - o) * fraction;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn b;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t* Tests User Agent strings to identify narrow devices.\r\n\t\t*\r\n\t\t* @return {Boolean} `true` if the current device is a narrow device;\r\n\t\t* otherwise, `false`.\r\n\t\t*/\r\n\t\tisNarrowDevice: function () {\r\n\t\t\tvar ua = navigator.userAgent;\r\n\t\t\tswitch (platform.platformName) {\r\n\t\t\t\tcase 'ios':\r\n\t\t\t\t\treturn (/iP(?:hone|od;(?: U;)? CPU) OS (\\d+)/).test(ua);\r\n\t\t\t\tcase 'android':\r\n\t\t\t\t\treturn (/Mobile/).test(ua) && (platform.android > 2);\r\n\t\t\t\tcase 'androidChrome':\r\n\t\t\t\t\treturn (/Mobile/).test(ua);\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n* Contains the declaration for the {@link module:layout/FittableLayout~FittableLayout}, {@link module:layout/FittableLayout~FittableColumnsLayout}\r\n* and {@link module:layout/FittableLayout~FittableRowsLayout} kinds.\r\n* @module layout/FittableLayout\r\n*/\r\n\r\nvar\r\n\tkind = require('enyo/kind'),\r\n\tdom = require('enyo/dom'),\r\n\tControl = require('enyo/Control'),\r\n\tLayout = require('enyo/Layout');\r\n\r\nvar detector = document.createElement('div'),\r\n\tflexAvailable =\r\n\t\t(detector.style.flexBasis !== undefined) ||\r\n\t\t(detector.style.webkitFlexBasis !== undefined) ||\r\n\t\t(detector.style.mozFlexBasis !== undefined) ||\r\n\t\t(detector.style.msFlexBasis !== undefined);\r\n\r\n/**\r\n* {@link module:layout/FittableLayout~FittableLayout} provides the base\r\n* positioning and boundary logic for the fittable layout strategy. The fittable\r\n* layout strategy is based on laying out items in either a set of rows or a set\r\n* of columns, with most of the items having natural size, but one item expanding\r\n* to fill the remaining space. The item that expands is labeled with the\r\n* attribute `fit: true`.\r\n*\r\n* The subkinds {@link module:layout/FittableLayout~FittableColumnsLayout} and\r\n* {@link module:layout/FittableLayout~FittableRowsLayout} (or _their_ subkinds)\r\n* are used for layout rather than `FittableLayout` because they specify\r\n* properties that the framework expects to be available when laying items out.\r\n*\r\n* When available on the platform, you can opt-in to have `FittableLayout` use\r\n* CSS flexible box (flexbox) to implement fitting behavior on the platform for\r\n* better performance; Enyo will fall back to JavaScript-based layout on older\r\n* platforms. Three subtle differences between the flexbox and JavaScript\r\n* implementations should be noted:\r\n\r\n* - When using flexbox, vertical margins (i.e., `margin-top`, `margin-bottom`) will\r\n* not collapse; when using JavaScript layout, vertical margins will collapse according\r\n* to static layout rules.\r\n*\r\n* - When using flexbox, non-fitting children of the Fittable must not be sized\r\n* using percentages of the container (even if set to `position: relative`);\r\n* this is explicitly not supported by the flexbox 2013 spec.\r\n*\r\n* - The flexbox-based Fittable implementation will respect multiple children\r\n* with `fit: true` (the fitting space will be divided equally between them).\r\n* This is NOT supported by the JavaScript implementation, and you should not rely\r\n* upon this behavior if you are deploying to platforms without flexbox support.\r\n*\r\n* The flexbox implementation was added to Enyo 2.5.0 as an optional performance\r\n* optimization; to use the optimization, set `useFlex: true` on the Fittable\r\n* container.  This will cause flexbox to be used when possible.\r\n*\r\n* @class FittableLayout\r\n* @extends module:enyo/Layout~Layout\r\n* @public\r\n*/\r\nvar FittableLayout = module.exports = kind(/** @lends module:layout/FittableLayout~FittableLayout.prototype */{\r\n\tname: 'enyo.FittableLayout',\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tkind: Layout,\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tnoDefer: true,\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tconstructor: function () {\r\n\t\tLayout.prototype._constructor.apply(this, arguments);\r\n\r\n\t\t// Add the force-ltr class if we're in RTL mode, but this control is set explicitly to NOT be in RTL mode.\r\n\t\tthis.container.addRemoveClass('force-left-to-right', (Control.prototype.rtl && !this.container.get('rtl')) );\r\n\r\n\t\t// Flexbox optimization is determined by global flexAvailable and per-instance opt-in useFlex flag\r\n\t\tthis.useFlex = flexAvailable && (this.container.useFlex === true);\r\n\t\tif (this.useFlex) {\r\n\t\t\tthis.container.addClass(this.flexLayoutClass);\r\n\t\t} else {\r\n\t\t\tthis.container.addClass(this.fitLayoutClass);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tcalcFitIndex: function () {\r\n\t\tvar aChildren = this.container.children,\r\n\t\t\toChild,\r\n\t\t\tn;\r\n\r\n\t\tfor (n=0; n<aChildren.length; n++) {\r\n\t\t\toChild = aChildren[n];\r\n\t\t\tif (oChild.fit && oChild.showing) {\r\n\t\t\t\treturn n;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tgetFitControl: function () {\r\n\t\tvar aChildren = this.container.children,\r\n\t\t\toFitChild = aChildren[this.fitIndex];\r\n\r\n\t\tif (!(oFitChild && oFitChild.fit && oFitChild.showing)) {\r\n\t\t\tthis.fitIndex = this.calcFitIndex();\r\n\t\t\toFitChild = aChildren[this.fitIndex];\r\n\t\t}\r\n\t\treturn oFitChild;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tshouldReverse: function () {\r\n\t\treturn this.container.rtl && this.orient === 'h';\r\n\t},\r\n\t\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tdestroy: function () {\r\n\t\tLayout.prototype.destroy.apply(this, arguments);\r\n\t\t\r\n\t\tif (this.container) {\r\n\t\t\tthis.container.removeClass(this.useFlex ? this.flexLayoutClass : this.fitLayoutClass);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tgetFirstChild: function() {\r\n\t\tvar aChildren = this.getShowingChildren();\r\n\r\n\t\tif (this.shouldReverse()) {\r\n\t\t\treturn aChildren[aChildren.length - 1];\r\n\t\t} else {\r\n\t\t\treturn aChildren[0];\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tgetLastChild: function() {\r\n\t\tvar aChildren = this.getShowingChildren();\r\n\r\n\t\tif (this.shouldReverse()) {\r\n\t\t\treturn aChildren[0];\r\n\t\t} else {\r\n\t\t\treturn aChildren[aChildren.length - 1];\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tgetShowingChildren: function() {\r\n\t\tvar a = [],\r\n\t\t\tn = 0,\r\n\t\t\taChildren = this.container.children,\r\n\t\t\tnLength   = aChildren.length;\r\n\r\n\t\tfor (;n<nLength; n++) {\r\n\t\t\tif (aChildren[n].showing) {\r\n\t\t\t\ta.push(aChildren[n]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\t_reflow: function(sMeasureName, sClienMeasure, sAttrBefore, sAttrAfter) {\r\n\t\tthis.container.addRemoveClass('enyo-stretch', !this.container.noStretch);\r\n\t\t\r\n\t\tvar oFitChild       = this.getFitControl(),\r\n\t\t\toContainerNode  = this.container.hasNode(),  // Container node\r\n\t\t\tnTotalSize     = 0,                          // Total container width or height without padding\r\n\t\t\tnBeforeOffset   = 0,                         // Offset before fit child\r\n\t\t\tnAfterOffset    = 0,                         // Offset after fit child\r\n\t\t\toPadding,                                    // Object containing t,b,r,l paddings\r\n\t\t\toBounds,                                     // Bounds object of fit control\r\n\t\t\toLastChild,\r\n\t\t\toFirstChild,\r\n\t\t\tnFitSize;\r\n\r\n\t\tif (!oFitChild || !oContainerNode) { return true; }\r\n\r\n\t\toPadding   = dom.calcPaddingExtents(oContainerNode);\r\n\t\toBounds    = oFitChild.getBounds();\r\n\t\tnTotalSize = oContainerNode[sClienMeasure] - (oPadding[sAttrBefore] + oPadding[sAttrAfter]);\r\n\r\n\t\t// If total size is zero, there's nothing for us to do (and the Control\r\n\t\t// we're doing layout for is probably hidden). In this case, we\r\n\t\t// short-circuit and return `true` to signify that we want to reflow\r\n\t\t// again the next time the Control is shown.\r\n\t\tif (nTotalSize === 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (this.shouldReverse()) {\r\n\t\t\toFirstChild  = this.getFirstChild();\r\n\t\t\tnAfterOffset = nTotalSize - (oBounds[sAttrBefore] + oBounds[sMeasureName]);\r\n\r\n\t\t\tvar nMarginBeforeFirstChild = dom.getComputedBoxValue(oFirstChild.hasNode(), 'margin', sAttrBefore) || 0;\r\n\r\n\t\t\tif (oFirstChild == oFitChild) {\r\n\t\t\t\tnBeforeOffset = nMarginBeforeFirstChild;\r\n\t\t\t} else {\r\n\t\t\t\tvar oFirstChildBounds      = oFirstChild.getBounds(),\r\n\t\t\t\t\tnSpaceBeforeFirstChild = oFirstChildBounds[sAttrBefore] - (oPadding[sAttrBefore] || 0);\r\n\r\n\t\t\t\tnBeforeOffset = oBounds[sAttrBefore] + nMarginBeforeFirstChild - nSpaceBeforeFirstChild;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\toLastChild    = this.getLastChild();\r\n\t\t\tnBeforeOffset = oBounds[sAttrBefore] - (oPadding[sAttrBefore] || 0);\r\n\r\n\t\t\tvar nMarginAfterLastChild = dom.getComputedBoxValue(oLastChild.hasNode(), 'margin', sAttrAfter) || 0;\r\n\r\n\t\t\tif (oLastChild == oFitChild) {\r\n\t\t\t\tnAfterOffset = nMarginAfterLastChild;\r\n\t\t\t} else {\r\n\t\t\t\tvar oLastChildBounds = oLastChild.getBounds(),\r\n\t\t\t\t\tnFitChildEnd     = oBounds[sAttrBefore] + oBounds[sMeasureName],\r\n\t\t\t\t\tnLastChildEnd    = oLastChildBounds[sAttrBefore] + oLastChildBounds[sMeasureName] +  nMarginAfterLastChild;\r\n\r\n\t\t\t\tnAfterOffset = nLastChildEnd - nFitChildEnd;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnFitSize = nTotalSize - (nBeforeOffset + nAfterOffset);\r\n\t\toFitChild.applyStyle(sMeasureName, nFitSize + 'px');\r\n\t},\r\n\r\n\t/**\r\n\t* Assigns any static layout properties not dependent on changes to the\r\n\t* rendered component or container sizes, etc.\r\n\t* \r\n\t* @public\r\n\t*/\r\n\tflow: function() {\r\n\t\tif (this.useFlex) {\r\n\t\t\tvar i,\r\n\t\t\t\tchildren = this.container.children,\r\n\t\t\t\tchild;\r\n\t\t\tthis.container.addClass(this.flexLayoutClass);\r\n\t\t\tthis.container.addRemoveClass('nostretch', this.container.noStretch);\r\n\t\t\tfor (i=0; i<children.length; i++) {\r\n\t\t\t\tchild = children[i];\r\n\t\t\t\tchild.addClass('enyo-flex-item');\r\n\t\t\t\tchild.addRemoveClass('flex', child.fit);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Updates the layout to reflect any changes made to the layout container or\r\n\t* the contained components.\r\n\t*\r\n\t* @public\r\n\t*/\r\n\treflow: function() {\r\n\t\tif (!this.useFlex) {\r\n\t\t\tif (this.orient == 'h') {\r\n\t\t\t\treturn this._reflow('width', 'clientWidth', 'left', 'right');\r\n\t\t\t} else {\r\n\t\t\t\treturn this._reflow('height', 'clientHeight', 'top', 'bottom');\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t* @lends module:layout/FittableLayout~FittableLayout.prototype\r\n\t*/\r\n\tstatics: {\r\n\t\t/**\r\n\t\t* Indicates whether flexbox optimization can be used.\r\n\t\t*\r\n\t\t* @type {Boolean}\r\n\t\t* @default  false\r\n\t\t* @private\r\n\t\t*/\r\n\t\tflexAvailable: flexAvailable\r\n\t}\r\n});\r\n\r\n/**\r\n* {@link module:layout/FittableLayout~FittableColumnsLayout} provides a\r\n* container in which items are laid out in a set of vertical columns, with most\r\n* of the items having natural size, but one expanding to fill the remaining\r\n* space. The one that expands is labeled with the attribute `fit: true`.\r\n*\r\n* `FittableColumnsLayout` is meant to be used as a value for the `layoutKind`\r\n* property of other kinds. `layoutKind` provides a way to add layout behavior in\r\n* a pluggable fashion while retaining the ability to use a specific base kind.\r\n*\r\n* For more information, see the documentation on\r\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\r\n* Enyo Developer Guide.\r\n*\r\n* @class FittableColumnsLayout\r\n* @extends module:layout/FittableLayout~FittableLayout\r\n* @public\r\n*/\r\n\r\n/**\r\n* The declaration for {@link module:layout/FittableLayout~FittableColumnsLayout}\r\n*/\r\nmodule.exports.Columns = kind(/** @lends module:layout/FittableLayout~FittableColumnsLayout.prototype */{\r\n\tname        : 'enyo.FittableColumnsLayout',\r\n\tkind        : FittableLayout,\r\n\torient      : 'h',\r\n\tfitLayoutClass : 'enyo-fittable-columns-layout',\r\n\tflexLayoutClass: 'enyo-flex-container columns'\r\n});\r\n\r\n\r\n/**\r\n* {@link module:layout/FittableLayout~FittableRowsLayout} provides a container\r\n* in which items are laid out in a set of horizontal rows, with most of the\r\n* items having natural size, but one expanding to fill the remaining space. The\r\n* one that expands is labeled with the attribute `fit: true`.\r\n*\r\n* `FittableRowsLayout` is meant to be used as a value for the `layoutKind`\r\n* property of other kinds. `layoutKind` provides a way to add layout behavior in\r\n* a pluggable fashion while retaining the ability to use a specific base kind.\r\n*\r\n* For more information, see the documentation on\r\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\r\n* Enyo Developer Guide.\r\n*\r\n* @class FittableRowsLayout\r\n* @extends module:layout/FittableLayout~FittableLayout\r\n* @public\r\n*/\r\n\r\n/**\r\n* The declaration for {@link module:layout/FittableLayout~FittableRowsLayout}\r\n*/\r\nmodule.exports.Rows = kind(\r\n\t/** @lends module:layout/FittableLayout~FittableRowsLayout.prototype */ {\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tname        : 'enyo.FittableRowsLayout',\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tkind        : FittableLayout,\r\n\r\n\t/**\r\n\t* Layout CSS class used to fit rows.\r\n\t*\r\n\t* @type {String}\r\n\t* @default 'enyo-fittable-rows-layout'\r\n\t* @public\r\n\t*/\r\n\tfitLayoutClass : 'enyo-fittable-rows-layout',\r\n\r\n\t/**\r\n\t* The orientation of the layout.\r\n\t*\r\n\t* @type {String}\r\n\t* @default 'v'\r\n\t* @public\r\n\t*/\r\n\torient      : 'v',\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tflexLayoutClass: 'enyo-flex-container rows'\r\n});\r\n","/**\r\n* Contains the declaration for the {@link module:layout/FlyweightRepeater~FlyweightRepeater} kind.\r\n* @module layout/FlyweightRepeater\r\n*/\r\n\r\nvar\r\n\tkind = require('enyo/kind'),\r\n\tdom = require('enyo/dom'),\r\n\tutils = require('enyo/utils'),\r\n\tControl = require('enyo/Control'),\r\n\tHTMLStringDelegate = require('enyo/HTMLStringDelegate'),\r\n\tSelection = require('enyo/Selection');\r\n\r\nvar FlyweightRepeaterDelegate = Object.create(HTMLStringDelegate);\r\n\r\nFlyweightRepeaterDelegate.generateInnerHtml = function (control) {\r\n\tvar h = '';\r\n\tcontrol.index = null;\r\n\t// note: can supply a rowOffset\r\n\t// and indicate if rows should be rendered top down or bottomUp\r\n\tfor (var i=0, r=0; i<control.count; i++) {\r\n\t\tr = control.rowOffset + (this.bottomUp ? control.count - i-1 : i);\r\n\t\tcontrol.setupItem(r);\r\n\t\tcontrol.$.client.setAttribute('data-enyo-index', r);\r\n\t\tif (control.orient == 'h') {\r\n\t\t\tcontrol.$.client.setStyle('display:inline-block;');\r\n\t\t}\r\n\t\th += HTMLStringDelegate.generateChildHtml(control);\r\n\t\tcontrol.$.client.teardownRender();\r\n\t}\r\n\treturn h;\r\n};\r\n\r\n/**\r\n* Fires once per row at render time.\r\n*\r\n* @event module:layout/FlyweightRepeater~FlyweightRepeater#onSetupItem\r\n* @type {Object}\r\n* @property {Number} index     - The index of the row being rendered.\r\n* @property {Boolean} selected - `true` if the row is selected; otherwise, `false`.\r\n* @public\r\n*/\r\n\r\n/**\r\n* Fires after an individual row has been rendered.\r\n*\r\n* @event module:layout/FlyweightRepeater~FlyweightRepeater#onRenderRow\r\n* @type {Object}\r\n* @property {Number} rowIndex - The index of the row that was rendered.\r\n* @public\r\n*/\r\n\r\n/**\r\n* {@link module:layout/FlyweightRepeater~FlyweightRepeater} is a control that displays a repeating list of\r\n* rows, suitable for displaying medium-sized lists (up to ~100 items). A\r\n* flyweight strategy is employed to render one set of row controls, as needed,\r\n* for as many rows as are contained in the repeater.\r\n*\r\n* The FlyweightRepeater's `components` block contains the controls to be used\r\n* for a single row. This set of controls will be rendered for each row. You\r\n* may customize row rendering by handling the\r\n* [onSetupItem]{@link module:layout/FlyweightRepeater~FlyweightRepeater#onSetupItem} event.\r\n*\r\n* The controls inside a FlyweightRepeater are non-interactive. This means that\r\n* calling methods that would normally cause rendering to occur (e.g.,\r\n* `set('content', <value>)`) will not do so. However, you may force a row to\r\n* render by calling [renderRow()]{@link module:layout/FlyweightRepeater~FlyweightRepeater#renderRow}.\r\n*\r\n* In addition, you may force a row to be temporarily interactive by calling\r\n* [prepareRow()]{@link module:layout/FlyweightRepeater~FlyweightRepeater#prepareRow}. Call\r\n* [lockRow()]{@link module:layout/FlyweightRepeater~FlyweightRepeater#lockRow} when the interaction\r\n* is complete.\r\n*\r\n* For more information, see the documentation on\r\n* [Lists]{@linkplain $dev-guide/building-apps/layout/lists.html} in the\r\n* Enyo Developer Guide.\r\n*\r\n* @class FlyweightRepeater\r\n* @extends module:enyo/Control~Control\r\n* @ui\r\n* @public\r\n*/\r\nvar FlyweightRepeater = module.exports = kind(\r\n\t/** @lends module:layout/FlyweightRepeater~FlyweightRepeater.prototype */ {\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tname: 'enyo.FlyweightRepeater',\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tkind: Control,\r\n\r\n\t/**\r\n\t* @lends module:layout/FlyweightRepeater~FlyweightRepeater.prototype\r\n\t* @private\r\n\t*/\r\n\tpublished: {\r\n\t\t/**\r\n\t\t * The number of rows to render.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t * @default 0\r\n\t\t * @public\r\n\t\t */\r\n\t\tcount: 0,\r\n\r\n\t\t/**\r\n\t\t* If `true`, the selection mechanism is disabled. Tap events are still\r\n\t\t* sent, but items won't be automatically re-rendered when tapped.\r\n\t\t*\r\n\t\t* @type {Boolean}\r\n\t\t* @default false\r\n\t\t* @public\r\n\t\t*/\r\n\t\tnoSelect: false,\r\n\r\n\t\t/**\r\n\t\t * If `true`, multiple selection is allowed.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t * @default false\r\n\t\t * @public\r\n\t\t */\r\n\t\tmultiSelect: false,\r\n\r\n\t\t/**\r\n\t\t * If `true`, the selected item will toggle.\r\n\t\t *\r\n\t\t * @type {Boolean}\r\n\t\t * @default false\r\n\t\t * @public\r\n\t\t */\r\n\t\ttoggleSelected: false,\r\n\r\n\t\t/**\r\n\t\t* Used to specify CSS classes for the repeater's wrapper component (client).\r\n\t\t* Input is identical to that of {@link module:enyo/Control~Control#setClasses}.\r\n\t\t*\r\n\t\t* @type {String}\r\n\t\t* @default ''\r\n\t\t* @public\r\n\t\t*/\r\n\t\tclientClasses: '',\r\n\r\n\t\t/**\r\n\t\t* Used to specify custom styling for the repeater's wrapper component\r\n\t\t* (client). Input is identical to that of {@link module:enyo/Control~Control#setStyle}.\r\n\t\t*\r\n\t\t* @type {String}\r\n\t\t* @default ''\r\n\t\t* @public\r\n\t\t*/\r\n\t\tclientStyle: '',\r\n\r\n\t\t/**\r\n\t\t* Numerical offset applied to row number during row generation. Allows items\r\n\t\t* to have natural indices instead of `0`-based ones. This value must be\r\n\t\t* positive, as row number `-1` is used to represent undefined rows in the\r\n\t\t* event system.\r\n\t\t*\r\n\t\t* @type {Number}\r\n\t\t* @default 0\r\n\t\t* @public\r\n\t\t*/\r\n\t\trowOffset: 0,\r\n\r\n\t\t/**\r\n\t\t* Direction in which items will be laid out. Valid values are `'v'` for\r\n\t\t* vertical or `'h'` for horizontal.\r\n\t\t*\r\n\t\t* @type {String}\r\n\t\t* @default 'h'\r\n\t\t* @public\r\n\t\t*/\r\n\t\torient: 'v'\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tevents: {\r\n\t\tonSetupItem: '',\r\n\t\tonRenderRow: ''\r\n\t},\r\n\r\n\t/**\r\n\t* Setting cachePoint: true ensures that events from the repeater's subtree will\r\n\t* always bubble up through the repeater, allowing the events to be decorated with repeater-\r\n\t* related metadata and references.\r\n\t*\r\n\t* @type {Boolean}\r\n\t* @default true\r\n\t* @private\r\n\t*/\r\n\tcachePoint: true,\r\n\r\n\t/**\r\n\t* Design-time attribute indicating whether row indices run\r\n\t* from `0` to [`count`]{@link module:layout/FlyweightRepeater~FlyweightRepeater#count}`-1` `(false)` or\r\n\t* from [`count`]{@link module:layout/FlyweightRepeater~FlyweightRepeater#count}`-1` to `0` `(true)`.\r\n\t*\r\n\t* @type {Boolean}\r\n\t* @default false\r\n\t* @public\r\n\t*/\r\n\tbottomUp: false,\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\trenderDelegate: FlyweightRepeaterDelegate,\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tcomponents: [\r\n\t\t{kind: Selection, onSelect: 'selectDeselect', onDeselect: 'selectDeselect'},\r\n\t\t{name: 'client'}\r\n\t],\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tcreate: function () {\r\n\t\tControl.prototype.create.apply(this, arguments);\r\n\t\tthis.noSelectChanged();\r\n\t\tthis.multiSelectChanged();\r\n\t\tthis.clientClassesChanged();\r\n\t\tthis.clientStyleChanged();\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tnoSelectChanged: function () {\r\n\t\tif (this.noSelect) {\r\n\t\t\tthis.$.selection.clear();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tmultiSelectChanged: function () {\r\n\t\tthis.$.selection.setMulti(this.multiSelect);\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tclientClassesChanged: function () {\r\n\t\tthis.$.client.setClasses(this.clientClasses);\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tclientStyleChanged: function () {\r\n\t\tthis.$.client.setStyle(this.clientStyle);\r\n\t},\r\n\r\n\t/**\r\n\t* @fires module:layout/FlyweightRepeater~FlyweightRepeater#onSetupItem\r\n\t* @private\r\n\t*/\r\n\tsetupItem: function (index) {\r\n\t\tthis.doSetupItem({index: index, selected: this.isSelected(index)});\r\n\t},\r\n\r\n\t/**\r\n\t* Renders the list.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tgenerateChildHtml: function () {\r\n\t\treturn this.renderDelegate.generateInnerHtml(this);\r\n\t},\r\n\r\n\t/**\r\n\t* @todo add link to preview.js\r\n\t* @private\r\n\t*/\r\n\tpreviewDomEvent: function (event) {\r\n\t\tvar i = this.index = this.rowForEvent(event);\r\n\t\tevent.rowIndex = event.index = i;\r\n\t\tevent.flyweight = this;\r\n\t},\r\n\r\n\t/**\r\n\t* @method\r\n\t* @private\r\n\t*/\r\n\tdecorateEvent: function (eventName, event, sender) {\r\n\t\t// decorate event with index found via dom iff event does not already contain an index.\r\n\t\tvar i = (event && event.index != null) ? event.index : this.index;\r\n\t\tif (event && i != null) {\r\n\t\t\tevent.index = i;\r\n\t\t\tevent.flyweight = this;\r\n\t\t}\r\n\t\tControl.prototype.decorateEvent.apply(this, arguments);\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\ttap: function (sender, event) {\r\n\t\t// ignore taps if selecting is disabled or if they don't target a row\r\n\t\tif (this.noSelect || event.index === -1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.toggleSelected) {\r\n\t\t\tthis.$.selection.toggle(event.index);\r\n\t\t} else {\r\n\t\t\tthis.$.selection.select(event.index);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Handler for selection and deselection.\r\n\t*\r\n\t* @private\r\n\t*/\r\n\tselectDeselect: function (sender, event) {\r\n\t\tthis.renderRow(event.key);\r\n\t},\r\n\r\n\t/**\r\n\t* Returns the repeater's [selection]{@link module:enyo/Selection~Selection} component.\r\n\t*\r\n\t* @return {module:enyo/Selection~Selection} The repeater's selection component.\r\n\t* @public\r\n\t*/\r\n\tgetSelection: function () {\r\n\t\treturn this.$.selection;\r\n\t},\r\n\r\n\t/**\r\n\t* Gets the selection state for the given row index.\r\n\t*\r\n\t* @return {Boolean} `true` if the row is currently selected; otherwise, `false`.\r\n\t* @public\r\n\t*/\r\n\tisSelected: function (index) {\r\n\t\treturn this.getSelection().isSelected(index);\r\n\t},\r\n\r\n\t/**\r\n\t* Renders the row with the specified index.\r\n\t*\r\n\t* @param {Number} index - The index of the row to render.\r\n\t* @fires module:layout/FlyweightRepeater~FlyweightRepeater#onRenderRow\r\n\t* @public\r\n\t*/\r\n\trenderRow: function (index) {\r\n\t\t// do nothing if index is out-of-range\r\n\t\tif (index < this.rowOffset || index >= this.count + this.rowOffset) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t//this.index = null;\r\n\t\t// always call the setupItem callback, as we may rely on the post-render state\r\n\t\tthis.setupItem(index);\r\n\t\tvar node = this.fetchRowNode(index);\r\n\t\tif (node) {\r\n\t\t\t// hack to keep this working...\r\n\t\t\tvar delegate = HTMLStringDelegate;\r\n\r\n\t\t\tdom.setInnerHtml(node, delegate.generateChildHtml(this.$.client));\r\n\t\t\tthis.$.client.teardownChildren();\r\n\t\t\tthis.doRenderRow({rowIndex: index});\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Fetches the DOM node for the given row index.\r\n\t*\r\n\t* @param {Number} index - The index of the row whose DOM node is to be fetched.\r\n\t* @return {Node} The DOM node for the specified row.\r\n\t* @public\r\n\t*/\r\n\tfetchRowNode: function (index) {\r\n\t\tif (this.hasNode()) {\r\n\t\t\treturn this.node.querySelector('[data-enyo-index=\"' + index + '\"]');\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* Fetches the row number corresponding to the target of a given event.\r\n\t*\r\n\t* @param {Object} event - Event object.\r\n\t* @return {Number} The index of the row corresponding to the event's target.\r\n\t* @public\r\n\t*/\r\n\trowForEvent: function (event) {\r\n\t\tif (!this.hasNode()) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tvar n = event.target;\r\n\t\twhile (n && n !== this.node) {\r\n\t\t\tvar i = n.getAttribute && n.getAttribute('data-enyo-index');\r\n\t\t\tif (i !== null) {\r\n\t\t\t\treturn Number(i);\r\n\t\t\t}\r\n\t\t\tn = n.parentNode;\r\n\t\t}\r\n\t\treturn -1;\r\n\t},\r\n\r\n\t/**\r\n\t* Prepares the specified row such that changes made to the controls inside\r\n\t* the repeater will be rendered for the row.\r\n\t*\r\n\t* @param {Number} index - The index of the row to be prepared.\r\n\t* @public\r\n\t*/\r\n\tprepareRow: function (index) {\r\n\t\t// do nothing if index is out-of-range\r\n\t\tif (index < this.rowOffset || index >= this.count + this.rowOffset) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// update row internals to match model\r\n\t\tthis.setupItem(index);\r\n\t\tvar n = this.fetchRowNode(index);\r\n\t\tFlyweightRepeater.claimNode(this.$.client, n);\r\n\t},\r\n\r\n\t/**\r\n\t* Prevents rendering of changes made to controls inside the repeater.\r\n\t*\r\n\t* @public\r\n\t*/\r\n\tlockRow: function () {\r\n\t\tthis.$.client.teardownChildren();\r\n\t},\r\n\r\n\t/**\r\n\t* Prepares the specified row such that changes made to the controls in the\r\n\t* repeater will be rendered in the row; then performs the function `func`\r\n\t* and, finally, locks the row.\r\n\t*\r\n\t* @param {Number} index   - The index of the row to be acted upon.\r\n\t* @param {Function} func  - The function to perform.\r\n\t* @param {Object} context - The context to which `func` is bound.\r\n\t* @private\r\n\t*/\r\n\tperformOnRow: function (index, func, context) {\r\n\t\t// do nothing if index is out-of-range\r\n\t\tif (index < this.rowOffset || index >= this.count + this.rowOffset) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (func) {\r\n\t\t\tthis.prepareRow(index);\r\n\t\t\tutils.call(context || null, func);\r\n\t\t\tthis.lockRow();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t* @lends module:layout/FlyweightRepeater~FlyweightRepeater\r\n\t* @private\r\n\t*/\r\n\tstatics: {\r\n\t\t/**\r\n\t\t* Associates a flyweight rendered control (`control`) with a\r\n\t\t* rendering context specified by `node`.\r\n\t\t*\r\n\t\t* @param {module:enyo/Control~Control} control - A flyweight-rendered control.\r\n\t\t* @param {Node} node - The DOM node to be associated with `control`.\r\n\t\t* @public\r\n\t\t*/\r\n\t\tclaimNode: function (control, node) {\r\n\t\t\tvar n;\r\n\t\t\tif (node) {\r\n\t\t\t\tif (node.id !== control.id) {\r\n\t\t\t\t\tn = node.querySelector('#' + control.id);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// node is already the right node, so just use it\r\n\t\t\t\t\tn = node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// FIXME: consider controls generated if we found a node or tag: null, the later so can teardown render\r\n\t\t\tcontrol.generated = Boolean(n || !control.tag);\r\n\t\t\tcontrol.node = n;\r\n\t\t\tif (control.node) {\r\n\t\t\t\tcontrol.rendered();\r\n\t\t\t} else {\r\n\t\t\t\t//enyo.log('Failed to find node for',  control.id, control.generated);\r\n\t\t\t}\r\n\t\t\t// update control's class cache based on the node contents\r\n\t\t\tfor (var i=0, c$=control.children, c; (c=c$[i]); i++) {\r\n\t\t\t\tthis.claimNode(c, node);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n* Contains the declaration for the {@link module:layout/FittableRows~FittableRows} kind.\r\n* @module layout/FittableRows\r\n*/\r\n\r\nvar\r\n\tkind = require('enyo/kind')\t;\r\n\r\nvar\r\n\tFittableLayout = require('./FittableLayout'),\r\n\tFittableRowsLayout = FittableLayout.Rows;\r\n\r\n/**\r\n* {@link module:layout/FittableRows~FittableRows} provides a container in which items are laid out in a\r\n* set\tof horizontal rows, with most of the items having natural size, but one\r\n* expanding to fill the remaining space. The one that expands is labeled with\r\n* the attribute `fit: true`.\r\n*\r\n* For more information, see the documentation on\r\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\r\n* Enyo Developer Guide.\r\n*\r\n* @class FittableRows\r\n* @extends module:enyo/Control~Control\r\n* @ui\r\n* @public\r\n*/\r\nmodule.exports = kind(/** @lends module:layout/FittableRows~FittableRows.prototype */{\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tname: 'enyo.FittableRows',\r\n\r\n\t/**\r\n\t* A {@glossary kind} used to manage the size and placement of child\r\n\t* [components]{@link module:enyo/Component~Component}.\r\n\t*\r\n\t* @type {String}\r\n\t* @default ''\r\n\t* @private\r\n\t*/\r\n\tlayoutKind: FittableRowsLayout,\r\n\r\n\t/**\r\n\t* By default, items in columns stretch to fit horizontally; set to `true` to\r\n\t* avoid this behavior.\r\n\t*\r\n\t* @type {Boolean}\r\n\t* @default false\r\n\t* @public\r\n\t*/\r\n\tnoStretch: false\r\n});\r\n","/**\r\n* Contains the declaration for the {@link module:layout/FittableColumns~FittableColumns} kind.\r\n* @module layout/FittableColumns\r\n*/\r\n\r\nvar\r\n\tkind = require('enyo/kind');\r\n\r\nvar\r\n\tFittableLayout = require('./FittableLayout'),\r\n\tFittableColumnsLayout = FittableLayout.Columns;\r\n\r\n/**\r\n* {@link module:layout/FittableColumns~FittableColumns} provides a container in which items are laid out in a\r\n* set of vertical columns, with most items having natural size, but one\r\n* expanding to fill the remaining space. The one that expands is labeled with\r\n* the attribute `fit: true`.\r\n*\r\n* For more information, see the documentation on\r\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\r\n* Enyo Developer Guide.\r\n*\r\n* @class FittableColumns\r\n* @extends module:enyo/Control~Control\r\n* @ui\r\n* @public\r\n*/\r\nmodule.exports = kind(/** @lends module:layout/FittableColumns~FittableColumns.prototype */ {\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\tname: 'enyo.FittableColumns',\r\n\r\n\t/**\r\n\t* A {@glossary kind} used to manage the size and placement of child\r\n\t* [components]{@link module:enyo/Component~Component}.\r\n\t*\r\n\t* @type {String}\r\n\t* @default ''\r\n\t* @private\r\n\t*/\r\n\tlayoutKind: FittableColumnsLayout,\r\n\r\n\t/**\r\n\t* By default, items in columns stretch to fit vertically; set to `true` to\r\n\t* avoid this behavior.\r\n\t*\r\n\t* @type {Boolean}\r\n\t* @default false\r\n\t* @public\r\n\t*/\r\n\tnoStretch: false\r\n});\r\n"]}